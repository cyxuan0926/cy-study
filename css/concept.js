/**
 *  使用CSS自定义属性(有时候也被称为css变量或者级联变量)是由CSS作者定义的 它包含的值可以在整个文档中重复使用.由自定义属性标记设定值(比如:--main-color: black)
 *  由var()函数来获取值(比如：color: var(--main-color)) 自定义属性受级联的约束 并从其父级继承其值
 *  基本用法：
 *    声明一个自定义属性 属性名需要以两个减号(--)开始 属性值则可以是任何有效的CSS值/和其他属性一样 自定义属也是写在规则集之内的.注意 规则集所指定的选择器定义了
 *    自定义属性的可见作用域/通常的最佳实践是定义在根伪类:root下 这样就可以在HTML文档的任何地方访问到它了/然而这条规则不是绝对的 如果有理由去限制你的自定义属性
 *    那么就应该限制/自定义属性是大小写敏感的
 *  自定义属性的继承性：
 *    自定义属性会继承。这意味着如果在一个给定的元素上 没有为这个自定义属性设置值 在其父元素上的值会被使用
 *    这些自定义属性的值仅当需要的时候才好计算 而并不会按其他规则进行保存 比如 你不能为元素设置一个属性 然后
 *    让它从兄弟或旁支子孙规则上获取值/属性仅用于匹配当前选择器及其子孙 这和通常的CSS是一样的
 *  自定义属性备用值：(fallback:备用值)
 *    用var()函数可以定义多个备用值 当给定值未定义时将会用备用值替换/函数的第一个参数是自定义属性的名称 如果提供了第二个参数 则表示备用值 当自定义属性值无效时生效
 *    第二个参数可以嵌套 但是不能继续平铺展开下去了
 *  有效值和值：
 *    传统的CSS概念里 有效值和属性是绑定的 这对自定义属性来说并不适用。当自定义属性值被解析 浏览器不知道它们什么时候会被使用 所以必须认为这些值都是有效的 不幸的是
 *    即便这些值是有效的 但当通过var()函数调用时 它在特定上下文环境也可能不会奏效/属性和自定义变量会导致无效的CSS语句 这引入了一个新的概念：计算时有效性
 *  无效变量会导致什么：
 *    当浏览器遇到无效的var()时 会使用继承值或初始值替换
 *      检查属性是否为继承属性 是 但是没有任何父元素定义了该属性 转到下一步
 *      将该值设置为它的默认初始值
 *  javascript中的值
 *    在JavaScript中获取或者修改CSS变量和操作普通CSS属性是一样的
 *  getComputedStyle:(elem, pseudoEit:指定一个要匹配的伪元素的字符串 必须对普通元素省略(或null))
 *    window.getComputedStyle()方法返回一个对象 该对象在应用活动样式并解析这些值可能包含的任何基本计算后报告元素的所有CSS属性的值;返回的style是一个实时的CSSStyleDeclaration
 *    对象 当元素的样式更改时 它会自动更新自身
 *    与伪元素一起使用：getComputedStyle可以从伪元素拉取样式信息
 *    注意：返回的CSSStyleDeclaration对象将包含所有支持的CSS属性长名称的活动值,所以仅使用font-size这样的长名称来查询是最安全的 也允许使用驼峰命名 比如fontSize
 *          CSS属性值可以使用getPropertyValue(propName)API或直接索引到对象
 *          在Firefox中 属性值为auto的会直接返回使用值 而不是auto
 *  CSSStyleDeclaration:
 *    该接口表示一个对象 它是一个CSS声明块 CSS属性键值对的集合 它暴露了样式信息和各种与样式相关的方法和属性
 *  defaultView:
 *    在浏览器中 该属性返回当前document对象所关联的window对象 如果没有 会返回null
 *    在许多在线演示代码中 getComputedStyle是通过document.defaultView对象来调用的 大部分情况下 这是不需要的 因为可以直接通过window对象调用 但有一种情况 你必需要使用defaultView
 *    那是在firefox3.6上访问子框架内的样式
 *  Window:
 *    该对象表示一个包含DOM文档的窗口 其document属性指向窗口中载入的DOM文档 使用document.defaultView属性可以获取指定文档所在窗口/ window作为全局变量 代表了脚本正在运行的窗口 暴露
 *    给JavaScript
*/