/** 
 * Atomics:此对象提供了一组静态方法用来对sharedArrayBuffer对象进行原子操作。这些原子操作属于Atomics模块 与一般的全局对象不同 Atomics不是构造函数 因此不能使用new操作符调用
 * 也不能将其当作函数直接调用。Atomics的所有属性和方法都是静态的。
 * 方法：
 *  多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始 ，其操作过程不会中断
 * 等待和呼唤
 *  wait() 和 wake() 可以让进程一直等待直到某个特定的条件为真 主要用于实现阻塞
 *  Atomics.wait()
 *    检测数组中某个指定位置上的值是否仍然是给定值 是则保持挂起直到被唤醒或超时 返回'ok'、'no-equal'、'timed-out'
 *  Atomics.wake()
 *    唤醒等待队列中正在数组指定位置的元素上等待的线程 返回值为成功唤醒的线程数量
 * 并行(Parallelism)和并发(Concurrency)
 *  并行(Parallelism): 同时执行读个任务
 *  并发(Concurrency): 在重叠的时间段内 执行几个任务
 *  两者密切相关 但也不一样
 *    并行(Parallelism)中没有并发(Concurrency): 单个指令 多数据多次计算并行发生 但是在任何给定的时刻都只执行一个任务(指令)
 *    并发(Concurrency)中没有并行(Parallelism): 单核CPU上通过时间分配进行多任务处理
 *  并行模式
 *    数据并行
 *      同一段代码并行执行多次 这些实例操作同一数据集的不同元素
 *    任务并行
 *      并行执行不同的代码段
 *  JS并行的历史
 *    JavaScript在单线程中执行。 某些任务可以异步执行：浏览器通常会在单线程中运行这些任务 然后通过回调将结果重新加入到单线程中
 *    Web Worker将任务并行引入了JavaScript，每个wokers都有自己的全局环境，默认情况下 不共享任何内容
 *      workers之间的通信(或在workers和主线程之间的通信发展)：
 *        起初 你只能发送和接收字符串
 *        然后 引入结构化克隆 可以发送和接收数据副本。结构化克隆适用于大多数数据 甚至可以正确处理对象之间的循环引用 但是不能克隆error对象 function对象和DOM节点
 *        可在workers之间的转移数据：当接收方获得数据时 发送方失去访问权限
 *        通过WebGL使用GPU计算(它倾向于数据并行处理)
 *        输入：您的数据 转换为图像(逐个像素)
 *        处理：OpenGL像素着色器可以对GPU执行任意计算 您的像素着色器会转换输入图像
 *        输出：再次可以转换为你的数据类型的图像
 *   共享数字缓冲区(shared Array Buffers)
 *      共享阵列缓冲区是更高并发抽象的基本构建块。这种共享有两个好处
 *        你可以更快地在workers之间共享数据
 *        workers之间地协调变得更简单和更快(与postMessage()相比)
 *   创建和发送一个共享数组缓冲区(shared Array Buffers)
 *      main.js和worker.js
 *   Atomics:安全访问共享数据
 *      在单线程中 编译器可以进行优化 以破坏多线程代码
 *      然后在多线程环境中 这种优化可以防止我们使用此模式来等待另一个线程所作的更改
 *      多线程时 不能保证在同一个共享数组缓冲区上同步多个workers的操作
 *   提供了全局对象Atomics，该对象有三个主要用例
 *      同步
 *        可以用来与其他workers进行同步.store/load方法可以确保读取和写入安全
 *      等待通知
 *        使用while循环等待通知的效率不是很高，所以有wait/wake方法
 *      运算
 *        Atomics操作执行算术运算 这样做不会被中断 有助于同步
 *   问题：破坏值
 *      共享内存的另一个有问题是破坏值(garbage、垃圾)：读取时 可能会看到一个中间值 -既不是新值之前写入内存的值 也不是新值
 *      当且仅当以下情况下不会破坏
 *        读写都通过TypedArray(而不是Dataview)进行
 *        TypedArray和共享数组缓冲区(shared Array Buffers)都是对称的
 *          sharedArray.byteOffset % sharedArray.BTYES_PER_ELEMENT === 0
 *        TypedArray每个元素的字节数相同
 *   共享数组缓冲区(shared array buffers)的使用
 *      共享数组缓冲区和JavaScript的运行到完成语义
 *        JavaScript具有所谓的 run-to-completion semantics(运行到完成语义)：每个函数都可以依赖于不被另一个线程中断 直到它完成。函数变成事务 并且可以执行完整的算法
 *        而不需要任何人查看它们在中间状态下的数据
 *        共享数组缓冲区中断运行到完成：函数正在运行时的数据可以在函数运行时被另一个线程更改。
 *   使用共享数组缓冲区的代码到底快多少？
 *   示例
 *      使用共享锁
 *        在主线程中 我们设置了共享内存 使其编码一个封闭的锁 并将其发送给一个web worker 用户点击后 我们打开锁
 *      
*/