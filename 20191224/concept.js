/** 
 * 犀牛书(第六版 JavaScript 权威指南)
 * 第一章 JavaScript概述
 *  输入和输出功能(类似网络、存储和图形相关的复杂特性)是由JavaScript所属的'宿主环境'(host enviroment)提供的 这里所说的宿主环境通常是web浏览器
 *  1.1 JavaScript语言核心
 *    所有在双斜线之后的内容都属于注释/变量是表示值得一个符号名字/值可以通过等号赋值给变量/JavaScript中两个非常重要得数据类型是对象和数组
 *    javaScript中得最重要得类型是对象 通过.或[]来访问对象属性
 *    初始化表达式(initializer expression)：通过方括号定义数组和通过花括号定义对象属性名和属性值之间的映射关系的语法
 *    运算符作用于操作数 生成一个新的值(operator)/如果JavaScript中的'短语'是表达式的话 那么整个句子就称作语句
 *    函数：当将函数和对象合写在一起时 函数就变成了'方法'method/所有的JavaScript对象都含有方法
 *    我们也可以定义自己的方法 this关键字是对定义方法的对象的引用
 *  1.2 客户端JavaScript
 *    可以通过事件处理程序(event handler)来定义文档的行为/事件处理程序是一个在浏览器中注册的JavaScript函数 当特定类型的事件发生时浏览器便调用这个函数
 *    定义事件处理程序最简单的方法是 给HTML的以'on'为前缀的属性绑定一个回调
 * 第一部分
 *   JavaScript语言核心
 *   1. 词法结构
 *      1.1 字符集
 *          JavaScript程序是用Unicode字符集编写的
 *          1.1.1 区分大小写
 *                JavaScript是区分大小写的语言 HTML并不区分大小写
 *          1.1.2 注释
 *                注释不能有嵌套的注释
 *          1.1.3 直接量
 *                所谓直接量 就是程序中直接使用的数据值 12/1.2/'hello world'/'hi'
 *          1.1.4 标识符和保留字
 *                标识符就是一个名字 在JavaScript中 标识符用来对变量和函数进行命名或者用作JavaScript代码中某些循环语句中的跳转位置的标记
 *                JavaScript标识符必须以字母、下划线(_)或美元符($)开始 后续的字符可以是字母、数字、下划线或美元符(数字是不允许作为首字符出现的 以便JavaScript可以轻易区分标识符和数字)
 *                保留字：JavaScript把一些标识符拿出来用做自己的关键字 因此 就不能再再程序中把这些关键字用做标识符了
 *  2. 数值、值和变量
 *    在编程语言中 能够表示并操作的值的类型称作数据类型/变量是一个值得符号名称 可以通过名称来获得对值得引用/变量是一个值的符号名称 可以通过名称来获得对值得引用/ 原始类型和引用对象(对象类型)
 *    null(空) undefined(未定义) 它们通常分别代表了各自特殊类型得唯一得成员/ 对象(Object)是属性(property)的集合 每个属性都由(名/值对)/全局对象/普通的JavaScript对象是'命名值'的无序集合
 *    数组表示带编号的值的有序集合/函数是具有与它相关联的可执行代码的对象 通过调用函数来运行可执行代码 并返回运算结果/如果函数用来初始化(使用new运算符) 一个新的对象 称之为构造函数(constructor)
 *    每个构造函数定义了一类(class)对象- 由构造函数初始化的对象组成的集合/Date类定义了代表日期的对象/RegExp类定义了正则表达式/Error类定义了那些表示JavaScript程序中运行时错误和语法错误的对象
 *    JavaScript解释器有自己的内存管理机制 可以自动对内存进行垃圾回收(garbage collection)/在JavaScript中 只有null 和undefined 是无法拥有方法的值/可变(mutable)类型和不可变(immutable)类型
 *    JavaScript可以自由地进行数据类型转换/JavaScript变量是无类型的(untyped) 变量可以被赋予任何类型的值 同样一个变量也可以重新赋予不同类型的值
 *    2.1 数字
 *      JavaScript中的所有数字均用浮点数值表示/一个数字直接出现在JavaScript程序中 我们称之为数字直接量/在任何数字直接量前添加负号(-) 可以得到它们的负值 但负号是一元求反运算符
 *      2.1.1 整型直接量
 *        在JavaScript程序中 用一个数字序列表示一个十进制整数
 *      2.1.2 浮点型直接量
 *        浮点型直接量可以含有小数点 它们采用的是传统的实数写法 一个实数由整数 小数点 小数部分组成/JavaScript中的算术运算在溢出(overflow)、下溢(underflow)或被零整除时不会报错
 *        当数字运算结果超过JavaScript所能表示的数字上限(溢出) 结果为一个特殊的无穷大infinity/下溢是当运算结果无限接近于零并比JavaScript能表示的最小值还小的时候发生的一种情形 这情况下 JavaScript返回0
 *        NaN 不和任何值相等 包括自身 x!==x => x是NaN 或者isNaN()的作用与此类似/isFinite() NaN infinity -infinity为false 其余都是ture/负零值同样有些特殊 和正零值是相等的
 *      2.1.3 二进制浮点数和四舍五入错误
 *        二进制浮点数表示法并不能精确表示.1这样简单的数字
 *      2.1.4 日期和时间
 *        JavaScript语言核心包括Date()构造函数 用来创建表示日期和时间的对象/这些日期对象的方法为日期计算提供了简单的API 日期对象不像数那样是基本数据类型
 *      2.1.5 文本
 *        字符串(string)是一组由16位值组成的不可变的有序序列 每个字符通常来自unicode字符集/JavaScript通过字符串类型来表示文本/字符串的长度是其所含16位值得个数
 *      2.1.6 字符串直接量
 *        在JavaScript程序中的字符串直接量 是由单引号或双引号括起来的字符序列/转义符
 *      2.1.7 转义字符
 *        在JavaScript字符串中 反斜线(\)有着特殊的用途 反斜线符号后加一个字符 就不再表示它们的字面含义了 比如\n 换行符
 *        \0 是判断字符数组结束的标识 表示这字符串到结尾了 注 在字符数组中 \0是占一个位置的
 *        \b 退格符  \t 水平制表符 \n 换行符 \v 垂直制表符 \f 换页符 \r 回车符 \" 双引号 \' 单引号或撇号 \\ 反斜线 \xXX 两位16进制数 \xXXX 四位16进制数
 *      2.1.8 字符串的使用
 *        字符串的相加表示字符串的拼接
 *      2.1.9 模式匹配
 *        javaScript定义了RegExp()构造函数 用来创建表示文本匹配模式的对象。这些模式称为 正则表达式
 *      2.1.10 布尔值
 *        布尔值指代真或假 开或关 是或否 这个类型只有两个值 true和false/ 0 null undefined NaN ''返回false 其余所有值 包括所有对象都会转成true
 *      2.1.11 null 和 undefined
 *        null是JavaScript语言的关键字 它表示一个特殊值 常用来描述'空值' 可以将null认为是一个特殊的对象值 含义是'非对象' 实际上 通常认为null是它
 *        自有类型的唯一一个成员 它可以表示数字 字符串和对象是'无值'的
 *        JavaScript还有第二个值来表示值的空缺 用未定义的值表示更深层次的'空值' 它是变量的一种取值 表明变量没有初始化 如果要查询对象属性或数组元素的值
 *        返回undefined则说明这个属性或元素不存在 如果函数没有返回值 则返回undefined 也是这个类型的唯一成员
 *      2.1.12 全局对象
 *        全局对象(global object)的属性是全局定义的符号 JavaScript程序可以直接使用/在代码的最顶级 不在任何函数内的JavaScript代码 可以使用JavaScript关键字this来引用全局对象
 *      2.1.13 包装对象
 *        JavaScript对象是一种复合值：它是属性或已命名值得集合 通过"."符号来引用属性值/原始类型通过构造函数得到的变量就是这个原始类型的包装对象/null undefined没有包装对象 访问
 *        它们的属性会造成一个类型错误/存取字符串、数字或布尔值的属性时创建的临时对象称作包装对象/由于字符串、数字和布尔值的属性都是只读的 并且不能给它们定义新属性/需要注意的时 可以
 *        通过String() Number() Boolean()构造函数来显示创建包装对象/ == 认为原始值 和对于的包装对象是相等的 === 将它们视为不等
 *      2.1.14 不可变的原始值和可变的对象引用
 *        原始值是不可更改的/对象值都是引用(reference) 对象的比较均是引用的比较 当且仅当它们引用同一个基对象时 它们才相等
 *      2.1.15 类型转换
 *        JavaScript中得取值类型非常灵活 会根据具体的情景要求隐式转换
 *        undefined --- 'undefined'(string) --- NaN(number) --- false(boolean) --- throws TypeError(对象)
 *        null --- 'null'(string) --- 0(number) --- false(boolean) --- throws TypeError(对象)
 *        true --- 'true'(string) --- 1(number) --- (boolean) --- throws TypeError(对象)
 *        false --- 'false'(string) --- 0(number) --- (boolean) --- throws TypeError(对象)
 *        "" --- (string) --- 0(number) --- false(boolean) --- new String("")(对象)
 *        "1.2"(非空 数字) --- (string) --- 1.2(number) --- true(boolean) --- new String("1.2")(对象)
 *        "one"(非空 非数字) --- (string) --- NaN(number) --- true(boolean) --- new String("one")(对象)
 *        0 --- "0"(string) --- (number) --- false(boolean) --- new Number(0)(对象)
 *        -0 --- "0"(string) --- (number) --- false(boolean) --- new Number(-0)(对象)
 *        NaN --- "NaN"(string) --- (number) --- false(boolean) --- new Number(NaN)(对象)
 *        Infinity --- "Infinity"(string) --- (number) --- true(boolean) --- new Number(Infinity)(对象)
 *        -Infinity --- "-Infinity"(string) --- (number) --- true(boolean) --- new Number(-Infinity)(对象)
 *        1(无穷大 非零) --- "1"(string) --- (number) --- true(boolean) --- new Number(1)(对象)
 *      2.1.16 转换和相等性
 *        由于JavaScript可以做灵活的类型转换 因此其"=="相等运算符也随相等的含义灵活多变
 *      2.1.17 显示类型转换
 *        通过Boolean() Number() String() Object()进行显示类型转换/当不通过new 运算符调用这些函数时 它们会作为类型转换函数/除了null 和 undefined外的任何值都具有toString()方法 
 *        这个方法执行结果通常和String方法的返回结果一致/Object()函数在这种情况下不会抛出异常 它仅简单地返回一个新创建的空对象/JavaScript中的某些运算符会做隐式的类型转换/一元'+'运算符
 *        将其操作数转换为数字(注：一个操作数的的运算符叫做一元运算符)/在计算机程序中数字的解析和格式化是非常普通的工作 JavaScript中提供了专门的函数和方法用来做更加精确的数字到字符串(number-to-string)
 *        和字符串到数字(string-to-number)/Number类定义的toString()方法可以接收表示转换基数(radix) 默认是10进制的数/当处理财务或科学数据的时候 在做数字到字符串的转换过程中 你期望自己控制输出中小数点
 *        和有效数字数位 或者决定是否需要指数记数法/toFixed():根据小数点后的指定位数将数字转换为字符串 它从不使用指数记数法/toExponential(): 使用指数记数法将数字转换为指数形式的字符串 其中小数点前只有一位
 *        小数点后的位数则有参数指定(也就是说有效数字位数比指定的位数要多一位)/toPrecision()根据指定的有效数字位数将数字转换成字符串 如果有效数字的位数少于数字整数部分的位数 则转换成指数形式/注所以三个方法
 *        都会适当地进行四舍五入或填充0/Number()转换函数传入一个字符串 它会试图将其转为一个整数或浮点数直接量 这个方法只能基于十进制数进行转换 并且不能出现非法地尾随字符/parseInt()/parseFloat() parseInt、
 *        parseFloat都会跳过任意数量的前导空格 尽可能解析更多数值字符 并忽略后面的内容 如果第一个非空格字符是非法的数字直接量 将最终返回NaN
 *      2.1.18 对象转换为原始值
 *        对象到布尔值的转换非常简单：所以的对象(包括数组和函数)都转换为true/对于包装对象亦是如此 new Boolean() 是一个对象而不是原始值 它将转换为true/对象到字符串(object-to-string) 和对象到数字(object-to-number)
 *        的转换是通过调用代转换对象的方法来完成的/一个麻烦的事实是 JavaScript对象有两个不同的方法来执行转换 需要注意的是 这里提到的字符串和数字的转换规则只适用于本地对象(native object) 宿主对象(例如 由web浏览器定义的对象)
 *        根据各自的算法可以转换成字符串和数字/所以的对象继承了两个转换方法：toString() 返回一个反映这个对象的字符串/数组类(Array class)的toString方法将每个数组元素转换成一个字符串 并在元素之间添加逗号后合并成结果字符串
 *        函数类(Function class)的toString()方法返回这个函数的实现定义的表示方式 实际上 这里的实现方式是通常是将用户定义的函数转换为JavaScript源代码字符串/日期类(Date class)定义的toString()方法返回了一个可读的日期和时间字符串
 *        RegExp类(RegExp class)定义的toString()方法将RegExp对象转换为表示正则表达式直接量的字符串/另一个转换对象的函数是valueOf() 这个方法的任务并未详细定义 如果存在任意原始值 它就默认将对象转换为表示它的原始值 对象是复合值 而且
 *        大多数对象无法真正表示为一个原始值 因此默认的valueOf方法简单地返回对象本身 而不是返回一个原始值 数组 函数 正则表达式简单地继承了这个默认方法 调用这些类型地实例地valueOf方法只是简单返回对象本身 日期类定义的valueOf方法会返回一个
 *        时间戳/JavaScript中对象到字符串的转换经过了如下这些步骤： 如果对象具有toString方法 则调用这个方法 如果它返回一个原始值 JavaScript将这个值转换为字符串 并返回这个字符串结果 如果对象没有toString方法 或者这个办法并不返回一个原始值
 *        那么JavaScript会调用valueOf方法 如果存在这个方法 则JavaScript调用它 如果返回值是原始值 JavaScript将这个值转换为字符串 并返回这个字符串结果 否则 JavaScript无法从toString或valueOf获得一个原始值 因此这是将抛出一个类型错误异常
 *        在对象到数字的转换过程中 JavaScript做了同样的事情 只是它会首先尝试使用valueOf方法：如果对象具有valueOf方法 后者返回一个原始值 则JavaScript将这个原始值转换为数字(如果需要的话)并返回这个数字 否则 如果对象具有toString方法 后者返回一个
 *        原始值 则JavaScript将其转换成数字类型并返回 否则JavaScript抛出一个类型错误的异常/JavaScript中的'+'运算符可以进行数学加法和字符串连接操作 如果它的其中一个操作数是对象 则JavaScript将使用特殊的方法将对象转换为原始值 而不是使用其他算术运算符
 *        的方法执行对象到数字的转换/对于所有非日期的对象来说 对象到原始值的转换基本上是对象到数字的转换(首先调用valueOf) 日期对象则使用对象到字符串的转换模式 然而 这里的转换通过valueOf或toString返回的原始值将被直接使用 而不会被强制转换为数字或字符串
 *        '+'、'=='、'!='和关系运算符是唯一执行这种特殊的字符串到原始值的转换方式的运算符
 *      2.1.19 变量声明
 *        JavaScript程序中 使用一个变量之前应当先声明 var/let/const/ 编程语言分为动态(类型)和静态(类型) 动态类型语言是指在运行期间才去做数据类型检查的语言 静态类型 它的数据类型在编译期间检查的
 *        重复的声明和遗漏的声明：声明提前/不好的习惯
 *      2.1.20 变量作用域
 *        一个变量的作用域(scope)是程序源代码中定义这个变量的区域 --- 全局变量(全局作用域) 局部变量(局部作用域)/在函数体内 局部变量的优先级高于同名的全局变量
 *      2.1.21 函数作用域和声明提前
 *        花括号内的每一段代码都具有各自的作用域 而且变量在声明它们的代码段之外是不可见的 我们称之为块级作用域(block scope) JavaScript里还有函数作用域(function scope)/JavaScript的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的 JavaScript
 *        函数里声明的所有变量(但不涉及赋值)都被'提前'至函数体的顶部
 *      2.1.22 作为属性的变量
 *        当声明一个JavaScript全局变量时 实际上是定义了全局对象的一个属性 当使用var声明一个变量时 创建的这个属性是不可配置的 也就是说这个变量无法通过delete运算符删除/如果你没有使用严格模式并给一个未声明的变量赋值的话 JavaScript会自动创建一个全局变量 以
 *        这种方式创建的变量是全局对象的正常的可配置属性/局部变量当作跟函数调用相关的某个对象的属性 这个对象称为 '调用对象'(call object) ES5规范称为'声明上下文对象'(declarative environment record)
 *      2.1.23 作用域链(scope chain)
 *        这个作用域链是一个对象列表或者链表 这组对象定义了这段代码'作用域中'的变量/当JavaScript需要查找变量x的值的时候(这个过程称作'变量解析'(variable resolution)) 它会从链中的第一个对象开始查找 一直查找下去 直到查找到或者不存在x(这时最终会抛出一个引用错误异常)
 *  3.表达式和运算符
 *      表达式(expression)JavaScript中的一个短语 JavaScript解释器会将其计算(evaluate)出一个结果/程序中的常量是最简单的一类表达式/将简单表达式组合成复杂表达式最常用的方法就是使用运算符(operator)
 *      4.1.1 原始表达式
 *        最简单的表达式是'原始表达式'(primary expression) 其是表达式的最小单位 包括常量、直接量 关键字和变量/undefined是全局变量 和 null 不同 它不是一个关键字
 *      4.1.2 对象和数组的初始化表达式
 *        对象和数组初始化表达式实际上是一个新创建的对象和数组 这些初始化表达式有时称作'对象直接量'和'数组直接量' 它们不是原始表达式 因为它们所包含的成员或者元素都是子表达式/数组初始化表达式是通过一对方括号和其内由逗号隔开的列表构成的 返回一个新创建的数组/数组初始化
 *        表达式的元素初始化表达式也可以是数组初始化表达式 也就是说 这些表达式是可以嵌套的/数组直接量中的列表逗号之间的元素可以省略 这时省略的空位会填充值undefined/数组直接量的元素列表结尾处可以留下单个逗号 这时并不会创建一个新的值为undefined
 *      4.1.3 函数定义表达式
 *        函数定义表达式定义一个JavaScript函数 表达式的值是这个新定义的函数 从某种意义上讲 函数定义表达式可称为'函数直接量' 一个典型的函数定义表达式包含关键字function 
 *      4.1.4 属性访问表达式
 *        属性访问表达式运算得到一个对象属性或一个数组元素的值 ./[] expression.identifier / expression[expression]/不管使用哪种形式的属性访问表达式 在'.' 和 '['之前的表达式总是会首先计算 如果计算结果是null或者undefined 表达式会抛出一个类型错误异常 因为这两个
 *        值都不能包含任意属性 如果运算结果不是对象(或者数组) JavaScript会将其转换为对象 如果改属性不存在 则会返回undefined/显然.identifier的写法更加简单 但需要注意的是 这种方式只适用于要访问的属性名是合法的标识符 并且需要知道访问的属性的名字 如果属性名是一个保留字
 *        或者包含空格和标调符号 或是一个数字 则必须使用方括号的写法 当属性名是通过运算得出的而不是固定的值的时候 这时必须使用方括号
 *      4.1.5 调用表达式
 *        JavaScript中的调用(invocation expression)是一种调用(或者执行)函数或方法的语法表示 functionName()/如果调用表达式的左圆括号之前的表达式是一个属性访问表达式 那么这个调用称为'方法调用'(method invocation)/在ES5的严格模式下定义的函数在调用时this指向undefined
 *        this不会指向全局对象
 *      4.1.6 对象创建表达式 object creation expression
 *        创建一个对象并调用一个函数(这个函数称作为构造函数)初始化新对象的属性 使用new 关键字开头/如果一个对象创建表达式不需要传入任何参数给构造函数的话 那么这对空圆括号时可以省略掉的/当计算一个对象创建表达式的值时 和对象初始化表达式通过{}创建对象的做法一样 如果一个构造
 *        函数确实返回一个对象值 那么这个对象就作为整个对象创建表达式的值 而那个新创建的对象就废弃了
 *      4.1.7 运算符概述
 *        运算符结合性：指一个操作数左右两边各有一个操作符时 先按照操作的优先级决定运算次序 如果优先级相同 再按照操作符的结合性来决定运算次数
 *          左结合：自左向右 即先左后右
 *          右结合性：自右向左 即先右后左
 *        运算符的优先级/结合性/操作个数/操作数类型->运算结果类型
 *        操作数的个数：运算符可以根据其操作数的个数进行分类：一元运算符 二元运算符 三元运算符
 *        操作数类型和结果类型: 一些运算符可以作用于任何数据类型 但仍然希望它们的操作数是指定类型的数据 并且大多数运算符返回一个特定类型的值/JavaScript运算符通常会根据需要对操作数进行类型转换/单个运算符的描述充分解释了它们对类型有着怎样的依赖以及操作数进行怎么样的类型转换
 *        左值：表达式只能出现在赋值运算符的左侧
 *        运算符的副作用
 *        运算符优先级：运算符优先级控制着运算符的执行顺序/需要注意的是 属性访问表达式和调用表达式的优先级是最高之一的
 *        运算符的结合性：在多个具有同样优先级的运算符表达式中的运算顺序/注 一元操作符、赋值、三元条件运算符都具有从右至左的结合性
 *        运算顺序：运算符的优先级和结合性规定了它们在复杂的表达式中的运算顺序 但并没有规定子表达式的计算过程中的运算顺序 JavaScript总是严格按照从左至右的顺序来计算表达式
 *      4.1.8 算术表达式 + - * / %
 *        1. '+'运算符
 *          二元加法运算符'+'可以对两个数字做加法 也可以做字符串链接操作 当两个操作数都是数字或都是字符串的时候 就是加法或者字符串链接/然而对于其他情况来说 则要进行一些必要的类型转换 并且运算符的行为依赖于类型转换的结果 加号的转换规则优先考虑字符串链接 如果其中一个操作数
 *          是字符串或者转换为字符串的对象 另一个操作数将会转换为字符串 加法将进行字符串的连接操作 如果两个操作数都不是类字符串(string-like)的 那么都将进行算是加法运算
 *          从技术上将 加法操作符的行为表现为：如果其中一个操作数是对象 则对象会遵守对象到原始值的转换规则转换为原始类值：日期对象通过toString()方法执行转换 其他对象则通过valueOf()方法执行(如果valueOf方法返回一个原始值的话) 由于多数对象都不具备可以的valueOf方法 因此
 *          它们会通过toString方法来执行 在进行了对象到原始值的转换后 如果其中一个操作数是字符串的话 另一个操作数也会转换为字符串 然后进行字符串连接 否则 两个操作数都将转换为数字(NaN) 然后进行加法操作/ 需要特别注意的是 当加号运算符和字符串和数字一起使用时 需要考虑加法的
 *          结合性的对运算顺序的影响 也就是说 运算结果是依赖于运算符的运算顺序的
 *        2. 一元算术运算符(+ - ++ --)
 *          一元运算符作用于一个单独的操作数 并产生一个新值 都是右结合(right-associative) 必要时 它们会将操作数转换为数字 需要注意的是 '+' 和 '-'是一元运算符 也是二元运算符
 *          一元加法(+): 一元加法运算符把操作数转换为数字(或者NaN) 并返回这个转换后的数字 如果操作数本身就是数字 则直接返回这个数字
 *          一元减法(-): 当'-'用作一元运算符时 它会根据需要把操作数转换为数字 然后改变运算结果的符号
 *          递增(++): 递增'++'运算符对其操作数进行增量(加一)操作 操作数是一个左值 运算符将操作数转换为数字 然后给数字加1 并将加1后的数值重新赋值给变量 数组原始或者对象属性/递增'++'运算符的返回值依赖于它相对于操作数的位置 当运算符在操作数之前 称之为'前增量'(pre-increment)
 *          运算符 它对操作数进行增量计算 并返回计算后的值 当运算符在操作数之后 称为'后增量'(post-increment)运算符 它对操作数进行增量计算 但返回未做增量计算的值(unincremented)/++x 并不总和 x = x + 1完全一样
 *          递减(--): 递减'-'运算符的操作数也是一个左值 它把操作数转换为数字 然后减1 并将计算后的值重新赋值给操作数
 *        3. 位运算符
 *          位运算符可以对由数字表示的二进制数据进行更低层次的按位运算 位运算要求它的操作数是整数 这些整数表示位32位整数而不是64位浮点数 必要时 位运算首先将操作数转换位数字 并将数字强制表示为32为整型 这回忽略原格式中的小数部分和任何超过32位的二进制位 需要注意的是 位运算
 *          会将NaN Infinity -Infinity都转换为0
 *          按位与(&): 位运算符'&'对它的整型操作数逐位执行布尔与(AND)操作
 *          按位或(|): 位运算符号'|'对它的整型操作数逐位执行布尔或(OR)操作
 *          按位异或(^)：位运算符号'……'对它的整型操作数逐位执行布尔或(XOR)操作 异或就是相异为1 相同为0 通常被称为不进位的加法
 *          按位非(~): 运算符'~'是一元运算符 位于一个整型参数之前 它将操作数的所有位取反 根据JavaScript中带符号的整数表示方法 对一个值使用'~'运算符相当于改变它的符号并减1
 *          左移(<<): 将第一个操作数的所有二进制位进行左移操作 移动的位数由第二个操作数指定 左移n位相当于乘以2^n 移动的位数是 0~31之间的一个整数
 *          带符号右移(>>)：将第一个操作数的所有二进制位进行右移操作 移动的位数由第二个操作数指定 右移n位相当于除以2^n 移动的位数是 0~31之间的一个整数 右边溢出的位将忽略 填补在左边的位由原操作数的符号来决定 如果第一个操作数是正数 移位后用0填补高位 如果第一个操作数是负数 移位后用1填补高位
 *          无符号右移(>>>): 与'>>'一样 只是左边的高位总是填补0 与原来的操作数符号无关
 *        4. 关系表达式
 *          关系运算符用于测试两个值之间的关系 而返回true或false
 *          相等和不等运算符：'=='和'==='运算符用于比较两个值是否相等/连个运算符允许任何类型的操作数 如果操作数相等则返回true 否则返回false '==='也称之为全等/严格相等运算符(strict equality)(identity operator) 它用来检测两个操作数是否严格相等/'=='用来检测两个操作数是否相等
 *          可以允许进行类型转换/JavaScript对象的比较是引用的比较 而不是值的比较 对象和其本身是相等的 但和任何其他对象都不相等 如果两个对象具有相同数量的属性 相同的属性名和值 它们依然是不相等的 相应位置的数组元素是相等的两个数组也是不相等的
 *          严格相等运算符 '==='首先计算其操作数的值 然后比较这两个值 比较过程没有任何类型转换：
 *            如果两个值类型不同 则它们不相等
 *            如果两个值都是null 或者undefined 则它们相等
 *            如果两个值都是布尔值true或者布尔值false 则它们相等
 *            如果其中一个值是NaN 或者两个值都是NaN 则它们不相等 NaN和其他任何值都是不相等的 包括它本身 x !== x来判断是否是NaN
 *            如果两个值为数字且数值相等 则它们相等 如果一个值为0 另一个值为 -0 则它们同样相等
 *            如果两个值为字符串 且所含的对应位上的16位数完全相等 则它们相等 如果它们的长度或内容不同 则它们不等 两个字符串可能含义完全一样且所显示出的字符也一样 但具有不同编码的16位值 '==='和'=='运算符的比较结果也是不相等
 *            如果两个引用值指向同一个对象 数组或函数 则它们相等 如果指向不同的对象 则它们是不等的 尽管两个对象具有完全一样的属性
 *         相等运算符(==) 相等运算符会尝试一些类型转换:
 *            如果两个操作数的类型相同 则和严格相等的比较规则一样
 *            如果两个操作数类型不同：
 *              如果一个值为null 一个值为 undefined 则它们相等
 *              如果一个值是数字 另一个是字符串 先将字符串转换为数字 然后使用转换后的值进行比较
 *              如果其中一个值是true 则将其转换为1再进行比较 如果其中一个值是false 则将其转换为0再进行比较
 *              如果一个值是对象 另一个值是数字或字符串 则将对象转换为原始值 然后再进行比较/通过toString或者valueOf方法转换为原始值 JavaScript语言核心的内置类首先尝试使用valueOf 再尝试toString 除了日期类 日期类只使用toString转换
 *              其他不同类型之间的比较均不相等
 *         比较运算符：用来检测两个操作数的大小关系(数值大小或者字母表的顺序)
 *            小于(<)/大于(>)/大于等于(>=)/小于等于(<=) 比较操作符的操作数可能是任意类型 然而 只有数字和字符串才能真正执行比较操作 因此如果操作数不是数字或者字符串 会进行类型转换
 *              如果操作数是对象: 先通过valueOf返回一个原始值 否则就使用toString的转换结果进行比较操作/字符串是对应位置上的Unicode字符的索引顺序进行比较
 *              对象转换为原始值之后 如果至少有一个操作数不是字符串 那么两个操作数都将转换为数字进行数字比较 0和-0相等 如果其中一个操作数是NaN 返回false 注：所有的大写的ASCII字母都小于 小写的ASCII字母 对于数字和字符串操作符来说 加号运算和比较
 *              运算的行为都有所不同 前者更偏爱字符串 只要有一个操作数为字符串 则进行字符串连接操作 而比较运算符则更偏爱数字 只有再两个操作数都是字符串的时候 才进行字符串的比较= 
 *              注 <= 和 >= 运算符在判断相等的时候 并不依赖于相等运算符和严格相等运算符的比较规则
 *         in运算符：希望它的左操作数是一个字符串或可以转换为字符串 它的右操作数是一个对象 如果右侧的对象拥有一个名为左侧操作数值的属性名 则返回true
 *         instanceof运算符：左操作数是一个对象 右操作数标识对象的类 如果左侧的对象是右侧类的实例 则返回true 否则返回false/注 所有的对象都是Object的实例 当通过instanceof判断一个对象是否是一个类的实例的时候 这个判断也会包含对'父类'的检测 如果instanceof
 *              的左操作数不是对象的话 返回false 如果右操作数不是函数 则抛出一个类型错误异常
 *       5. 逻辑表达式 && || ！
              逻辑与(&&): 当操作数都是布尔值的时候 '&&'对两个值执行布尔与(AND)操作 关系运算符的优先级比'&&'(和 '||')要高/但是'&&'的操作数并不一定是布尔值 &&运算符返回'真值'或者'假植'/&&的行为称为'短路'(short circuiting)
              逻辑或(||): 对两个操作数做布尔或(OR)运算 有且仅当两个操作数都是假值 返回一个假值
              逻辑非(!): 一元运算符 放置在一个单独的操作数之前 将操作数的布尔值进行求反 ！运算符首先将其操作数转换为布尔值 然后再对布尔值求反 !!x 则是一个值的等价布尔值 一个一元运算符 !具有很高的优先级 并且和操作数紧密绑定在一起
*/