/** 
 * 犀牛书(第六版 JavaScript 权威指南)
 * 第一章 JavaScript概述
 *  输入和输出功能(类似网络、存储和图形相关的复杂特性)是由JavaScript所属的'宿主环境'(host enviroment)提供的 这里所说的宿主环境通常是web浏览器
 *  1.1 JavaScript语言核心
 *    所有在双斜线之后的内容都属于注释/变量是表示值得一个符号名字/值可以通过等号赋值给变量/JavaScript中两个非常重要得数据类型是对象和数组
 *    javaScript中得最重要得类型是对象 通过.或[]来访问对象属性
 *    初始化表达式(initializer expression)：通过方括号定义数组和通过花括号定义对象属性名和属性值之间的映射关系的语法
 *    运算符作用于操作数 生成一个新的值(operator)/如果JavaScript中的'短语'是表达式的话 那么整个句子就称作语句
 *    函数：当将函数和对象合写在一起时 函数就变成了'方法'method/所有的JavaScript对象都含有方法
 *    我们也可以定义自己的方法 this关键字是对定义方法的对象的引用
 *  1.2 客户端JavaScript
 *    可以通过事件处理程序(event handler)来定义文档的行为/事件处理程序是一个在浏览器中注册的JavaScript函数 当特定类型的事件发生时浏览器便调用这个函数
 *    定义事件处理程序最简单的方法是 给HTML的以'on'为前缀的属性绑定一个回调
 * 第一部分
 *   JavaScript语言核心
 *   1. 词法结构
 *      1.1 字符集
 *          JavaScript程序是用Unicode字符集编写的
 *          1.1.1 区分大小写
 *                JavaScript是区分大小写的语言 HTML并不区分大小写
 *          1.1.2 注释
 *                注释不能有嵌套的注释
 *          1.1.3 直接量
 *                所谓直接量 就是程序中直接使用的数据值 12/1.2/'hello world'/'hi'
 *          1.1.4 标识符和保留字
 *                标识符就是一个名字 在JavaScript中 标识符用来对变量和函数进行命名或者用作JavaScript代码中某些循环语句中的跳转位置的标记
 *                JavaScript标识符必须以字母、下划线(_)或美元符($)开始 后续的字符可以是字母、数字、下划线或美元符(数字是不允许作为首字符出现的 以便JavaScript可以轻易区分标识符和数字)
 *                保留字：JavaScript把一些标识符拿出来用做自己的关键字 因此 就不能再再程序中把这些关键字用做标识符了
 *  2. 数值、值和变量
 *    在编程语言中 能够表示并操作的值的类型称作数据类型/变量是一个值得符号名称 可以通过名称来获得对值得引用/变量是一个值的符号名称 可以通过名称来获得对值得引用/ 原始类型和引用对象(对象类型)
 *    null(空) undefined(未定义) 它们通常分别代表了各自特殊类型得唯一得成员/ 对象(Object)是属性(property)的集合 每个属性都由(名/值对)/全局对象/普通的JavaScript对象是'命名值'的无序集合
 *    数组表示带编号的值的有序集合/函数是具有与它相关联的可执行代码的对象 通过调用函数来运行可执行代码 并返回运算结果/如果函数用来初始化(使用new运算符) 一个新的对象 称之为构造函数(constructor)
 *    每个构造函数定义了一类(class)对象- 由构造函数初始化的对象组成的集合/Date类定义了代表日期的对象/RegExp类定义了正则表达式/Error类定义了那些表示JavaScript程序中运行时错误和语法错误的对象
 *    JavaScript解释器有自己的内存管理机制 可以自动对内存进行垃圾回收(garbage collection)/在JavaScript中 只有null 和undefined 是无法拥有方法的值/可变(mutable)类型和不可变(immutable)类型
 *    JavaScript可以自由地进行数据类型转换/JavaScript变量是无类型的(untyped) 变量可以被赋予任何类型的值 同样一个变量也可以重新赋予不同类型的值
 *    2.1 数字
 *      JavaScript中的所有数字均用浮点数值表示/一个数字直接出现在JavaScript程序中 我们称之为数字直接量/在任何数字直接量前添加负号(-) 可以得到它们的负值 但负号是一元求反运算符
 *      2.1.1 整型直接量
 *        在JavaScript程序中 用一个数字序列表示一个十进制整数
 *      2.1.2 浮点型直接量
 *        浮点型直接量可以含有小数点 它们采用的是传统的实数写法 一个实数由整数 小数点 小数部分组成/JavaScript中的算术运算在溢出(overflow)、下溢(underflow)或被零整除时不会报错
 *        当数字运算结果超过JavaScript所能表示的数字上限(溢出) 结果为一个特殊的无穷大infinity/下溢是当运算结果无限接近于零并比JavaScript能表示的最小值还小的时候发生的一种情形 这情况下 JavaScript返回0
 *        NaN 不和任何值相等 包括自身 x!==x => x是NaN 或者isNaN()的作用与此类似/isFinite() NaN infinity -infinity为false 其余都是ture/负零值同样有些特殊 和正零值是相等的
 *      2.1.3 二进制浮点数和四舍五入错误
 *        二进制浮点数表示法并不能精确表示.1这样简单的数字
 *      2.1.4 日期和时间
 *        JavaScript语言核心包括Date()构造函数 用来创建表示日期和时间的对象/这些日期对象的方法为日期计算提供了简单的API 日期对象不像数那样是基本数据类型
 *      2.1.5 文本
 *        字符串(string)是一组由16位值组成的不可变的有序序列 每个字符通常来自unicode字符集/JavaScript通过字符串类型来表示文本/字符串的长度是其所含16位值得个数
 *      2.1.6 字符串直接量
 *        在JavaScript程序中的字符串直接量 是由单引号或双引号括起来的字符序列/转义符
 *      2.1.7 转义字符
 *        在JavaScript字符串中 反斜线(\)有着特殊的用途 反斜线符号后加一个字符 就不再表示它们的字面含义了 比如\n 换行符
 *        \0 是判断字符数组结束的标识 表示这字符串到结尾了 注 在字符数组中 \0是占一个位置的
 *        \b 退格符  \t 水平制表符 \n 换行符 \v 垂直制表符 \f 换页符 \r 回车符 \" 双引号 \' 单引号或撇号 \\ 反斜线 \xXX 两位16进制数 \xXXX 四位16进制数
 *      2.1.8 字符串的使用
 *        字符串的相加表示字符串的拼接
 *      2.1.9 模式匹配
 *        javaScript定义了RegExp()构造函数 用来创建表示文本匹配模式的对象。这些模式称为 正则表达式
 *      2.1.10 布尔值
 *        布尔值指代真或假 开或关 是或否 这个类型只有两个值 true和false/ 0 null undefined NaN ''返回false 其余所有值 包括所有对象都会转成true
 *      2.1.11 null 和 undefined
 *        null是JavaScript语言的关键字 它表示一个特殊值 常用来描述'空值' 可以将null认为是一个特殊的对象值 含义是'非对象' 实际上 通常认为null是它
 *        自有类型的唯一一个成员 它可以表示数字 字符串和对象是'无值'的
 *        JavaScript还有第二个值来表示值的空缺 用未定义的值表示更深层次的'空值' 它是变量的一种取值 表明变量没有初始化 如果要查询对象属性或数组元素的值
 *        返回undefined则说明这个属性或元素不存在 如果函数没有返回值 则返回undefined 也是这个类型的唯一成员
 *      2.1.12 全局对象
 *        全局对象(global object)的属性是全局定义的符号 JavaScript程序可以直接使用/在代码的最顶级 不在任何函数内的JavaScript代码 可以使用JavaScript关键字this来引用全局对象
 *      2.1.13 包装对象
 *        JavaScript对象是一种复合值：它是属性或已命名值得集合 通过"."符号来引用属性值/原始类型通过构造函数得到的变量就是这个原始类型的包装对象/null undefined没有包装对象 访问
 *        它们的属性会造成一个类型错误/存取字符串、数字或布尔值的属性时创建的临时对象称作包装对象/由于字符串、数字和布尔值的属性都是只读的 并且不能给它们定义新属性/需要注意的时 可以
 *        通过String() Number() Boolean()构造函数来显示创建包装对象/ == 认为原始值 和对于的包装对象是相等的 === 将它们视为不等
 *      2.1.14 不可变的原始值和可变的对象引用
 *        原始值是不可更改的/对象值都是引用(reference) 对象的比较均是引用的比较 当且仅当它们引用同一个基对象时 它们才相等
 *      2.1.15 类型转换
 *        JavaScript中得取值类型非常灵活 会根据具体的情景要求隐式转换
 *        undefined --- 'undefined'(string) --- NaN(number) --- false(boolean) --- throws TypeError(对象)
 *        null --- 'null'(string) --- 0(number) --- false(boolean) --- throws TypeError(对象)
 *        true --- 'true'(string) --- 1(number) --- (boolean) --- throws TypeError(对象)
 *        false --- 'false'(string) --- 0(number) --- (boolean) --- throws TypeError(对象)
 *        "" --- (string) --- 0(number) --- false(boolean) --- new String("")(对象)
 *        "1.2"(非空 数字) --- (string) --- 1.2(number) --- true(boolean) --- new String("1.2")(对象)
 *        "one"(非空 非数字) --- (string) --- NaN(number) --- true(boolean) --- new String("one")(对象)
 *        0 --- "0"(string) --- (number) --- false(boolean) --- new Number(0)(对象)
 *        -0 --- "0"(string) --- (number) --- false(boolean) --- new Number(-0)(对象)
 *        NaN --- "NaN"(string) --- (number) --- false(boolean) --- new Number(NaN)(对象)
 *        Infinity --- "Infinity"(string) --- (number) --- true(boolean) --- new Number(Infinity)(对象)
 *        -Infinity --- "-Infinity"(string) --- (number) --- true(boolean) --- new Number(-Infinity)(对象)
 *        1(无穷大 非零) --- "1"(string) --- (number) --- true(boolean) --- new Number(1)(对象)
 *      2.1.16 转换和相等性
 *        由于JavaScript可以做灵活的类型转换 因此其"=="相等运算符也随相等的含义灵活多变
 *      2.1.17 显示类型转换
 *        通过Boolean() Number() String() Object()进行显示类型转换/当不通过new 运算符调用这些函数时 它们会作为类型转换函数/除了null 和 undefined外的任何值都具有toString()方法 
 *        这个方法执行结果通常和String方法的返回结果一致/Object()函数在这种情况下不会抛出异常 它仅简单地返回一个新创建的空对象/JavaScript中的某些运算符会做隐式的类型转换/一元'+'运算符
 *        将其操作数转换为数字(注：一个操作数的的运算符叫做一元运算符)/在计算机程序中数字的解析和格式化是非常普通的工作 JavaScript中提供了专门的函数和方法用来做更加精确的数字到字符串(number-to-string)
 *        和字符串到数字(string-to-number)/Number类定义的toString()方法可以接收表示转换基数(radix) 默认是10进制的数/当处理财务或科学数据的时候 在做数字到字符串的转换过程中 你期望自己控制输出中小数点
 *        和有效数字数位 或者决定是否需要指数记数法/toFixed():根据小数点后的指定位数将数字转换为字符串 它从不使用指数记数法/toExponential(): 使用指数记数法将数字转换为指数形式的字符串 其中小数点前只有一位
 *        小数点后的位数则有参数指定(也就是说有效数字位数比指定的位数要多一位)/toPrecision()根据指定的有效数字位数将数字转换成字符串 如果有效数字的位数少于数字整数部分的位数 则转换成指数形式/注所以三个方法
 *        都会适当地进行四舍五入或填充0/Number()转换函数传入一个字符串 它会试图将其转为一个整数或浮点数直接量 这个方法只能基于十进制数进行转换 并且不能出现非法地尾随字符/parseInt()/parseFloat() parseInt、
 *        parseFloat都会跳过任意数量的前导空格 尽可能解析更多数值字符 并忽略后面的内容 如果第一个非空格字符是非法的数字直接量 将最终返回NaN
 *      2.1.18 对象转换为原始值
 *        对象到布尔值的转换非常简单：所以的对象(包括数组和函数)都转换为true/对于包装对象亦是如此 new Boolean() 是一个对象而不是原始值 它将转换为true/对象到字符串(object-to-string) 和对象到数字(object-to-number)
 *        的转换是通过调用代转换对象的方法来完成的/一个麻烦的事实是 JavaScript对象有两个不同的方法来执行转换 需要注意的是 这里提到的字符串和数字的转换规则只适用于本地对象(native object) 宿主对象(例如 由web浏览器定义的对象)
 *        根据各自的算法可以转换成字符串和数字/所以的对象继承了两个转换方法：toString() 返回一个反映这个对象的字符串/数组类(Array class)的toString方法将每个数组元素转换成一个字符串 并在元素之间添加逗号后合并成结果字符串
 *        函数类(Function class)的toString()方法返回这个函数的实现定义的表示方式 实际上 这里的实现方式是通常是将用户定义的函数转换为JavaScript源代码字符串/日期类(Date class)定义的toString()方法返回了一个可读的日期和时间字符串
 *        RegExp类(RegExp class)定义的toString()方法将RegExp对象转换为表示正则表达式直接量的字符串/另一个转换对象的函数是valueOf() 这个方法的任务并未详细定义 如果存在任意原始值 它就默认将对象转换为表示它的原始值 对象是复合值 而且
 *        大多数对象无法真正表示为一个原始值 因此默认的valueOf方法简单地返回对象本身 而不是返回一个原始值 数组 函数 正则表达式简单地继承了这个默认方法 调用这些类型地实例地valueOf方法只是简单返回对象本身 日期类定义的valueOf方法会返回一个
 *        时间戳/JavaScript中对象到字符串的转换经过了如下这些步骤： 如果对象具有toString方法 则调用这个方法 如果它返回一个原始值 JavaScript将这个值转换为字符串 并返回这个字符串结果 如果对象没有toString方法 或者这个办法并不返回一个原始值
 *        那么JavaScript会调用valueOf方法 如果存在这个方法 则JavaScript调用它 如果返回值是原始值 JavaScript将这个值转换为字符串 并返回这个字符串结果 否则 JavaScript无法从toString或valueOf获得一个原始值 因此这是将抛出一个类型错误异常
 *        在对象到数字的转换过程中 JavaScript做了同样的事情 只是它会首先尝试使用valueOf方法：如果对象具有valueOf方法 后者返回一个原始值 则JavaScript将这个原始值转换为数字(如果需要的话)并返回这个数字 否则 如果对象具有toString方法 后者返回一个
 *        原始值 则JavaScript将其转换成数字类型并返回 否则JavaScript抛出一个类型错误的异常/JavaScript中的'+'运算符可以进行数学加法和字符串连接操作 如果它的其中一个操作数是对象 则JavaScript将使用特殊的方法将对象转换为原始值 而不是使用其他算术运算符
 *        的方法执行对象到数字的转换/对于所有非日期的对象来说 对象到原始值的转换基本上是对象到数字的转换(首先调用valueOf) 日期对象则使用对象到字符串的转换模式 然而 这里的转换通过valueOf或toString返回的原始值将被直接使用 而不会被强制转换为数字或字符串
 *        '+'、'=='、'!='和关系运算符是唯一执行这种特殊的字符串到原始值的转换方式的运算符
 *      2.1.19 变量声明
 *        JavaScript程序中 使用一个变量之前应当先声明 var/let/const/ 编程语言分为动态(类型)和静态(类型) 动态类型语言是指在运行期间才去做数据类型检查的语言 静态类型 它的数据类型在编译期间检查的
 *        重复的声明和遗漏的声明：声明提前/不好的习惯
 *      2.1.20 变量作用域
 *        一个变量的作用域(scope)是程序源代码中定义这个变量的区域 --- 全局变量(全局作用域) 局部变量(局部作用域)/在函数体内 局部变量的优先级高于同名的全局变量
 *      2.1.21 函数作用域和声明提前
 *        花括号内的每一段代码都具有各自的作用域 而且变量在声明它们的代码段之外是不可见的 我们称之为块级作用域(block scope) JavaScript里还有函数作用域(function scope)/JavaScript的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的 JavaScript
 *        函数里声明的所有变量(但不涉及赋值)都被'提前'至函数体的顶部
 *      2.1.22 作为属性的变量
 *        当声明一个JavaScript全局变量时 实际上是定义了全局对象的一个属性 当使用var声明一个变量时 创建的这个属性是不可配置的 也就是说这个变量无法通过delete运算符删除/如果你没有使用严格模式并给一个未声明的变量赋值的话 JavaScript会自动创建一个全局变量 以
 *        这种方式创建的变量是全局对象的正常的可配置属性/局部变量当作跟函数调用相关的某个对象的属性 这个对象称为 '调用对象'(call object) ES5规范称为'声明上下文对象'(declarative environment record)
 *      2.1.23 作用域链(scope chain)
 *        这个作用域链是一个对象列表或者链表 这组对象定义了这段代码'作用域中'的变量/当JavaScript需要查找变量x的值的时候(这个过程称作'变量解析'(variable resolution)) 它会从链中的第一个对象开始查找 一直查找下去 直到查找到或者不存在x(这时最终会抛出一个引用错误异常)
 *  3.表达式和运算符
 *      表达式(expression)JavaScript中的一个短语 JavaScript解释器会将其计算(evaluate)出一个结果/程序中的常量是最简单的一类表达式/将简单表达式组合成复杂表达式最常用的方法就是使用运算符(operator)
 *      4.1.1 原始表达式
 *        最简单的表达式是'原始表达式'(primary expression) 其是表达式的最小单位 包括常量、直接量 关键字和变量/undefined是全局变量 和 null 不同 它不是一个关键字
 *      4.1.2 对象和数组的初始化表达式
 *        对象和数组初始化表达式实际上是一个新创建的对象和数组 这些初始化表达式有时称作'对象直接量'和'数组直接量' 它们不是原始表达式 因为它们所包含的成员或者元素都是子表达式/数组初始化表达式是通过一对方括号和其内由逗号隔开的列表构成的 返回一个新创建的数组/数组初始化
 *        表达式的元素初始化表达式也可以是数组初始化表达式 也就是说 这些表达式是可以嵌套的/数组直接量中的列表逗号之间的元素可以省略 这时省略的空位会填充值undefined/数组直接量的元素列表结尾处可以留下单个逗号 这时并不会创建一个新的值为undefined
 *      4.1.3 函数定义表达式
 *        函数定义表达式定义一个JavaScript函数 表达式的值是这个新定义的函数 从某种意义上讲 函数定义表达式可称为'函数直接量' 一个典型的函数定义表达式包含关键字function 
 *      4.1.4 属性访问表达式
 *        属性访问表达式运算得到一个对象属性或一个数组元素的值 ./[] expression.identifier / expression[expression]/不管使用哪种形式的属性访问表达式 在'.' 和 '['之前的表达式总是会首先计算 如果计算结果是null或者undefined 表达式会抛出一个类型错误异常 因为这两个
 *        值都不能包含任意属性 如果运算结果不是对象(或者数组) JavaScript会将其转换为对象 如果改属性不存在 则会返回undefined/显然.identifier的写法更加简单 但需要注意的是 这种方式只适用于要访问的属性名是合法的标识符 并且需要知道访问的属性的名字 如果属性名是一个保留字
 *        或者包含空格和标调符号 或是一个数字 则必须使用方括号的写法 当属性名是通过运算得出的而不是固定的值的时候 这时必须使用方括号
 *      4.1.5 调用表达式
 *        JavaScript中的调用(invocation expression)是一种调用(或者执行)函数或方法的语法表示 functionName()/如果调用表达式的左圆括号之前的表达式是一个属性访问表达式 那么这个调用称为'方法调用'(method invocation)/在ES5的严格模式下定义的函数在调用时this指向undefined
 *        this不会指向全局对象
 *      4.1.6 对象创建表达式 object creation expression
 *        创建一个对象并调用一个函数(这个函数称作为构造函数)初始化新对象的属性 使用new 关键字开头/如果一个对象创建表达式不需要传入任何参数给构造函数的话 那么这对空圆括号时可以省略掉的/当计算一个对象创建表达式的值时 和对象初始化表达式通过{}创建对象的做法一样 如果一个构造
 *        函数确实返回一个对象值 那么这个对象就作为整个对象创建表达式的值 而那个新创建的对象就废弃了
 *      4.1.7 运算符概述
 *        运算符的优先级/结合性/操作个数/操作数类型->运算结果类型
*/