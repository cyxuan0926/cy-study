/**
 * 组个API征求意见稿
 *  动机与目的
 *    更好的逻辑复用与代码组织
 *    更好的类型推导
 *  设计细节
 *    API介绍：
 *      为了不引入全新的概念 该提案中的API更像是暴露Vue的核心功能 比如用独立的函数来创建和监听响应式的状态等
 *    响应式状态与副作用
 *      import { reactive } from 'vue' reactive几乎等价于2.x中现有的Vue.observable()API
 *      在Vue中 响应式状态的基本用法就是在渲染时使用它 因为有了依赖追踪 视图会在响应式状态发生改变时自动更新
 *      在DOM当中渲染内容会被视为一种'副作用':程序会在外部修改起本身(也就是这个DOM)的状态 我们可以使用watchEffectAPI应用基于响应式状态的副作用 并自动进行重应用
 *      watchEffect应该接受一个应用预期副作用(这里即设置innerHTML)的函数 它会立即执行该函数 并将该执行过程中用到的所有响应式状态的property作为依赖进行追踪
 *    计算状态与Ref
 *      除了计算值的ref 我们还可以使用ref API直接创建一个可变更的普通的ref：
 *    解开Ref
 *      我们可以将一个ref值暴露给渲染上下文 在渲染过程中 Vue会直接使用其内部的值 也就是说在模板中你可以把{{count.value}}直接写成{{count}}
 *   API手册
 *    setup
 *      函数是一个新的组件选项 作为在组件内使用composition API的入口点/调用时机->创建组件实例 然后初始化props 紧接着就调用setup函数，从生命周期钩子的视角来看 它会在beforeCreate钩子之前被调用
 *      在模板中使用，如果setup返回一个对象 则对象的属性将会被合并到组件模块的渲染上下文;
 *      渲染函数/JSX中使用 setup也可以返回一个函数 函数中也能使用当前setup函数作用域中的响应式数据 函数中也能使用当前setup函数作用域中的响应式数据
 *      参数：该函数接收props作为其第一个参数, 然而不要解构props对象 那样会使其失去响应性/在开发过程中 对象对用户空间代码是不可变的 第二个参数提供了一个上下文对象
 *      attrs和slots都是内部组件实例上对应项的代理 可以确保在更新后仍然是最新值 所以可以解构 无需担心后面访问到过期的值
 *    this的用法
 *      this在setup()中不可用 由于setup()在解析2.x选项前被调用 setup()中this将与2.x选项中的this完全不同
 */